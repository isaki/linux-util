#!/usr/bin/perl -w

use strict;
use warnings;

use LWP::UserAgent;
use IO::File;
use IO::Pipe;
use Getopt::Long qw(:config bundling pass_through version);
use Data::Dumper qw();

use constant CORRETTO_BASE => q(https://apt.corretto.aws);
use constant VSCODE_BASE => q(https://packages.microsoft.com);
use constant GOOGLE_BASE => q(https://dl.google.com);
use constant DOCKER_BASE => q(https://download.docker.com);

use constant DEFAULT_TIMEOUT => 10;
use constant APT_KEY_EXE => q(/usr/bin/apt-key);
use constant APT_LIST_DIR => q(/etc/apt/sources.list.d);
use constant LSB_RELEASE_EXE => q(/usr/bin/lsb_release);
use constant DPKG_EXE => q(/usr/bin/dpkg);

our $VERSION = q(1.0.2);

our %REPOS = (
    'corretto' => RepoInfo->new(
        CORRETTO_BASE . '/corretto.key',
        CORRETTO_BASE,
        'stable',
        'main'),
    'vscode' => RepoInfo->new(
        VSCODE_BASE . '/keys/microsoft.asc',
        VSCODE_BASE . '/repos/code',
        'stable',
        'main',
        'amd64,arm64,armhf'),
    'google-chrome' => RepoInfo->new(
        GOOGLE_BASE . '/linux/linux_signing_key.pub',
        GOOGLE_BASE . '/linux/chrome/deb',
        'stable',
        'main',
        \&dpkg_arch),
    'docker' => RepoInfo->new(
        DOCKER_BASE . '/linux/ubuntu/gpg',
        DOCKER_BASE . '/linux/ubuntu',
        \&lsb_release,
        'stable',
        \&dpkg_arch)
);

# Option handling
my ($help, $timeout);
GetOptions(
    'h|help' => \$help,
    't|timeout=i' => \$timeout
) or die 'Please run with --help to see valid usage';

if ($help) {
    usage();
    exit(0);
}

if (defined $timeout) {
    die 'Invalid --timeout' if ($timeout < 0);
} else {
    $timeout = DEFAULT_TIMEOUT;
}

my @addRepos;
if (scalar(@ARGV) == 0) {
    die 'At least one repo must be specified; please run with --help to see valid repos';
} else {
    my %seen;
    my @names = grep { ! $seen{$_}++ } @ARGV;

    foreach my $n (@names) {
        die 'Invalid repo: ', $n unless (defined $REPOS{$n});
        push(@addRepos, [ $n, $REPOS{$n} ]);
    }
}

# We must run as root.
die 'This must be run as root or via sudo' unless ($< == 0);

# Main
foreach my $pair (@addRepos) {
    my $name = $pair->[0];
    my $info = $pair->[1];

    print STDOUT 'INFO: Processing ', $name, "\n";

    print STDOUT 'INFO: Fetching key data', "\n";
    my $keyData = get_key($info, $timeout);

    print STDOUT 'INFO: Key data:', "\n";
    print STDOUT Data::Dumper::Dumper($keyData);

    print STDOUT 'INFO: Registering key data with apt', "\n";
    register_key($keyData) or die 'ERROR: Failed to register key', "\n";

    print STDOUT 'INFO: Creating list entry in ', APT_LIST_DIR, "\n";
    create_source_list($info, $name);
}

print STDOUT qq(\n*** Please run 'apt-get update' or 'apt update' to pick up these changes! ***\n\n);

exit(0);

#
# Methods
#
sub get_key {
    my ($info, $timeout) = @_;

    my $userAgent = LWP::UserAgent->new();
    $userAgent->timeout($timeout);

    my $resp = $userAgent->get($info->getKey());

    die 'ERROR: Failed to retrieve key', "\n", Data::Dumper::Dumper($resp) unless ($resp->is_success());

    return $resp->content();
}

sub register_key {
    my ($keyData) = @_;

    my $pipe = IO::Pipe->new();
    my $pid = undef;

    if ($pid = fork()) {
        $pipe->writer();

        $pipe->print($keyData);
        $pipe->close();

        waitpid($pid, 0);

        return ($? >> 8) == 0;
    } elsif (defined $pid) {
        $pipe->reader();

        close(STDIN);
        open(STDIN, '<&', $pipe);

        my @cmd = (APT_KEY_EXE, 'add', '-');

        print STDOUT 'EXEC: ', join(' ', @cmd), "\n";
        exec(@cmd);
        exit($!);
    } else {
        die $!;
    }
}

sub create_source_list {
    my ($info, $name) = @_;

    my $file = APT_LIST_DIR . '/' . $name . '.list';

    my $fh = IO::File->new();
    $fh->open($file, 'w') or die 'ERROR: Failed to open ', $file, ' for write: ', $!;

    my $arch = $info->getArch();
    my $repo = $info->getRepo();
    my $c1 = $info->getComponentOne();
    my $c2 = $info->getComponentTwo();

    my @line = qw(deb);
    push(@line, '[arch=' . $arch . ']') if (defined $arch);
    push(@line, $repo, $c1, $c2);

    $fh->print(join(' ', @line), "\n");

    $fh->close or warn $!;

    return 1;
}

sub dpkg_arch {
    return load_single_line(DPKG_EXE, '--print-architecture');
}

sub lsb_release {
    return load_single_line(LSB_RELEASE_EXE, '-cs');
}

sub load_single_line {
    my (@cmd) = @_;

    my $pipe = IO::Pipe->new();
    my $pid = undef;

    if ($pid = fork()) {
        $pipe->reader();

        my $capture = undef;
        while (my $line = $pipe->getline()) {
            $capture = $line;
            chomp($capture);
        }

        $pipe->close();

        waitpid($pid, 0);

        if (($? >> 8) != 0) {
            die 'Command execution failure';
        }

        print STDOUT 'INFO: Result ', Data::Dumper::Dumper($capture);

        return $capture;
    } elsif (defined $pid) {
        $pipe->writer();

        print STDOUT 'EXEC: ', join(' ', @cmd), "\n";
        
        close(STDOUT);
        open(STDOUT, '>&', $pipe);

        exec(@cmd);
        exit($!);
    } else {
        die $!;
    }
}

sub usage {
    (my $scriptname = $0) =~ s!^.*/!!;

    print STDOUT <<__USAGE_END__;

Usage: $scriptname [--timeout <timeout>] <repo> [<repo>...]

    h|help          : Print this screen.
    t|timeout <int> : HTTP(S) fetch timeout.

Supported Repos:
__USAGE_END__

    print STDOUT '    ', $_, "\n" foreach (sort keys %REPOS);
    print STDOUT "\n";

    return 1;
}

#
# Objects
#
package RepoInfo;

use strict;
use warnings;

use Carp qw();

sub new {
    my $pkg = shift;
    return bless([ @_ ], $pkg);
}

sub getKey {
    return $_[0]->[0];
}

sub getRepo {
    return $_[0]->[1];
}

sub getComponentOne {
    return $_[0]->_processRef(2);
}

sub getComponentTwo {
    return $_[0]->_processRef(3);
}

sub getArch {
    my ($self) = @_;
    my $count = scalar(@{$self});
    return ($count > 4) ? $self->_processRef(4) : undef;
}

sub _processRef {
    my ($self, $idx) = @_;

    my $value = $self->[$idx];

    # Nothing to do
    return ($value) unless (ref($value));

    my $resolved = $value->();

    Carp::confess('Function pointer execution returned undefined at object index ', $idx) unless (defined $resolved);

    # Cache the result
    $self->[$idx] = $value;

    return $resolved;
}
