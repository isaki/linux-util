#!/usr/bin/perl -w

use strict;
use warnings;

use Cwd qw();
use IO::Pipe;

# Modes
use constant XDG_MODE => 1;
use constant WSL_MODE => 2;

# XDG Support
use constant XDG_CMD => q(xdg-open);

# WSL Support
use constant WSLINFO => q(/usr/bin/wslinfo);
use constant WSLINFO_TARGET => q(/init);
use constant WSLPATH => q(wslpath);
use constant WSL_CMD => q(explorer.exe);

die 'Running as root is forbidden' if ($< == 0);

my $argc = scalar(@ARGV);
die 'Invalid usage' if ($argc == 0);

my $mode = get_mode();

my @cmd;
$#cmd = $argc;

if ($mode == XDG_MODE) {
    die 'Running outside a desktop session is forbidden' unless (defined $ENV{'XDG_CURRENT_DESKTOP'});
    $cmd[0] = XDG_CMD;
    populate_cmd(\@cmd, \@ARGV, $argc, \&Cwd::abs_path);
} elsif ($mode == WSL_MODE) {
    $cmd[0] = WSL_CMD;
    populate_cmd(\@cmd, \@ARGV, $argc, \&wslpath);
} else {
    die 'Unable to determine operating mode';
}

print STDERR '[EXEC] ', join(' ', @cmd), qq(\n);
exec(@cmd);
exit($!);

sub get_mode {

    if (-l WSLINFO) {
        my $path = readlink(WSLINFO);

        if (defined $path) {
            return WSL_MODE if ($path eq WSLINFO_TARGET);
        } else {
            print STDERR 'Failed to determine symlink target for ',
                WSLINFO,
                ': ',
                $!,
                "\n";

            return 0;
        }
    }

    return XDG_MODE;
}

# void populate_xdg_command(char** cmd, const char** argv, const size_t argv, char* (*pfix)(const char*))
sub populate_cmd {
    my ($cmd, $argv, $argc, $pfix) = @_;

    for (my $i = 0; $i < $argc; ++$i) {
        # This copy makes the code easier to read.
        my $x = $argv->[$i];
        $cmd->[$i + 1] = ($x =~ /^-/ || $x =~ /^\S+:\/\//) ? $x : $pfix->($x);
    }

    return undef;
}

sub wslpath {
    my ($path) = @_;

    my $pid = undef;
    my $pipe = IO::Pipe->new();

    if ($pid = fork()) {
        $pipe->reader();

        my $ret = undef;
        my $i = 0;

        while (my $line = $pipe->getline()) {
            $ret = $line;
            ++$i;
        }

        $pipe->close();

        waitpid($pid, 0);

        if (($? >> 8) == 0 && $i == 1) {
            chomp($ret);
            return $ret;
        } else {
            return $path;
        }
    } elsif (defined $pid) {
        $pipe->writer();
        STDOUT->close();

        open(STDOUT, q(>&), $pipe);
        exec(WSLPATH, q(-w), $path);
        exit($!);
    } else {
        die $!;
    }

    die;
}
